{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2005-02-11-dtrace-on-demand-debugging-part-1/","result":{"data":{"site":{"siteMetadata":{"title":"Lambdacurry"}},"markdownRemark":{"id":"8b619400-5388-53c6-ad3d-e1265ce1b3d0","excerpt":"One of the best things that I have seen the OS world is Solaris 10 and its associated debug tools. This includes - Dtrace, mdb, libumem . Together they can be…","html":"<p>One of the best things that I have seen the OS world is Solaris 10 and its associated debug tools. This includes - <a href=\"http://technorati.com/tag/dtrace\">Dtrace</a>, mdb, libumem . Together they can be combined into one of the most powerful debug frameworks that exists. Move over purify… All that I have tried out is actually gleaned from user groups at various sun forums. But there is one thing Leventhal, Shapiro and Cantrill are gods.</p>\n<p>Alright, dtrace commands are very similar to mdb commands. The syntax is provider:module:function:name . The syntax is self explanatory, except the name part. This is a part which gives some part of the providers semantic meaning. e.g. exit will work when the function is about to exit. Some parts of the commands may be left blank. for example the pid provider pid1000::myFunc:entry is invoked when the function is entered.</p>\n<p>For me, the most interesting part is when, we need to debug loadable libraries. A little awkward, but very cool.</p>\n<p>dtrace -qwc a.out -n ‘pid$target:ld:dlopen:entry{printf(“pid=%d loading: %s\\n”,pid,copyinstr(arg0))}’</p>\n<p>This would print out the libraries that are being loaded. This small program hooks onto the pid of a.out using the pid provider. The $target is an implicit variable that gets the pid number of the a.out when it is run. Therefore consider the module ld. When the function dlopen in entered in this module (as part of the a.out process), dtrace will print the name of the library. Looking at the man page of dlopen, we can see that the first argument passed to the dlopen function (arg0) is the name of the loadable library. But we cannot print it directly. This is because dtrace operates in the solaris kernel space. To access names, etc. from the user-space, we need to copy them first to kernel space (via the copyinstr function). When the library you are interested in has loaded, suspend the process. In another shell,</p>\n<p>dtrace -n ‘pid:library_name::entry{printf(“function=%s probe= %s”,probefunc,probename);}’</p>\n<p>once dtrace has started its probes, resume the earlier suspended program. The pid provider, will be the most used provider for any software developer interested in looking at the execution trace of his/her programs.</p>\n<p>There is another feature of Solaris 10 which is of great help in locating leaks, debugging invalid memory accesses, etc. Maybe not so effective as valgrind or purify but hundred’s of times as fast. This is the libumem/mdb combo. Right now, I have only figured out how to detect memory leaks.</p>\n<p>setenv LD_PRELOAD libumem.so.1 setenv UMEM_DEBUG default setenv UMEM_LOGGING transaction</p>\n<p>. This is necessary for the libumem memory debugging library to be loaded.</p>\n<p>start the application using mdb</p>\n<p>mdb ./a.out</p>\n<blockquote>\n<p>::sysbp _exit        /* to break before the program exits */</p>\n</blockquote>\n<blockquote>\n<p>::run</p>\n</blockquote>\n<p>mdb: stop on entry to _exit\nmdb: target stopped at:\nlibc.so.1`exit+0x14:    ta        8\nmdb: You’ve got symbols!\nmdb: You’ve got symbols!\nLoading modules: [ ld.so.1 libumem.so.1 libc.so.1 ]</p>\n<p>Here comes the interesting part. Finding leaks is as simple as :</p>\n<h2>>::findleaks\nCACHE           LEAKED       BUFCTL          CALLER\nsomeaddress      somenumber   impAddress     function address</h2>\n<p>Total       1 buffer, 24 bytes</p>\n<blockquote>\n<p>impAddress::bufctl_audit   /* to backtrace a particular leak  */</p>\n</blockquote>\n<p>libumem.so.1`umem_cache_alloc+0x13c\nlibumem.so.1`umem_alloc+0x60\nlibumem.so.1`malloc+0x28\nmain+4\n_start+0x108</p>\n<blockquote>\n<p>::walk umem_log|::bufctl_audit   /* to backtrace all leaks */</p>\n</blockquote>\n<p>Whew.. end of day 1.</p>\n<p>del.icio.us Tags: <a href=\"http://del.icio.us/sss8ue/software\">software</a> <a href=\"http://del.icio.us/sss8ue/solaris\">solaris</a> <a href=\"http://del.icio.us/sss8ue/dtrace\">dtrace</a> <a href=\"http://del.icio.us/sss8ue/debug\">debug</a></p>","frontmatter":{"title":"[dtrace]  On demand debugging - Part 1","date":"February 11, 2005"}}},"pageContext":{"slug":"/blog/2005-02-11-dtrace-on-demand-debugging-part-1/","previous":{"fields":{"slug":"/blog/2005-02-06-business-mandates-for-software-sales-and-marketing/"},"frontmatter":{"title":"[Business] Mandates for Software Sales and  Marketing"}},"next":{"fields":{"slug":"/blog/2005-02-11-business-vcs-have-too-much-money-heres-how-to-pitch/"},"frontmatter":{"title":"[Business] VC's have too much money ? Here's how to pitch"}}}},"staticQueryHashes":["2778469899","2841359383","2882394463","3616023293"]}