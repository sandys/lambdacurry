{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2005-06-20-function-pointers-number-of-parameters-mismatch/","result":{"data":{"site":{"siteMetadata":{"title":"Lambdacurry"}},"markdownRemark":{"id":"23582e9e-79e0-52f5-96e2-f0f1cfc767ca","excerpt":"Here is a strange quirk of gcc - It ignores number-of-parameter mismatch if we use function pointers, if and only if we pass more arguments than necessary…","html":"<p>Here is a strange quirk of gcc - It ignores number-of-parameter mismatch if we use function pointers, if and only if we pass more arguments than necessary.<br>\nConsider the following piece of code</p>\n<p>#include &#x3C;stdio.h></p>\n<p>typedef int (*myFunc)(int a, int b);\nint func1(int a){\nprintf(“In func1 n”);\n}</p>\n<p>int func2(int a, int b){\nprintf(“In func2 n”);\n}</p>\n<p>void executeFunc(myFunc someFunc ){\n//void executeFunc(void* someFunc ){\nmyFunc actualFunc=someFunc;\nactualFunc(1,2);\n//actualFunc(1,2);</p>\n<p>}</p>\n<p>main(){\nexecuteFunc((myFunc)func1);</p>\n<p>}</p>\n<p>As you can see, I am actually calling “func1”, which takes one argument. However,I am actually passing two arguments. The code works fine.<br>\nStrangely enough, the other way does’nt work - i.e.</p>\n<p>#include &#x3C;stdio.h></p>\n<p>typedef int (*myFunc)(int a, int b);\nint func1(int a){\nprintf(“In func1 n”);\n}</p>\n<p>int func2(int a, int b){\nprintf(“In func2 n”);\n}</p>\n<p>void executeFunc(myFunc someFunc ){\n//void executeFunc(void* someFunc ){\nmyFunc actualFunc=someFunc;\nactualFunc(1,2);\n//actualFunc(1);</p>\n<p>}</p>\n<p>main(){\nexecuteFunc((myFunc)func2);</p>\n<p>}</p>\n<p>The above piece of code calls “func2”, which actually takes two arguments with only one parameter. Compilation fails in this case.<br>\nWhat is more puzzling is that, in case I had called “func1” directly (without going through all the function-pointers thing), it gives a compilation error of (too many arguments). I can deduce that gcc is doing checking w.r.t the “typedef” in the beginning, but given that ordinarily a function cannot be called with too many arguments, should’nt this be disallowed?<br>\n6.3.2.2 of C89 (which correspondsto 6.5.2.2 of C99) states that:</p>\n<blockquote>\n<p>If the expression that denotes the called function has a type that includes a prototype, the number of arguments shall agree with the number of parameters</p>\n</blockquote>\n<p>Which brings me to another “feature” of C vs C++. Consider the following function:</p>\n<p>#include &#x3C;stdio.h></p>\n<p>int func3(int a){\nreturn 1;</p>\n<p>}</p>\n<p>main(){\nfunc3(1,2,3);\n}</p>\n<p>This gives a compilation error with both “gcc” and “g++” about too many arguments.<br>\nHowever, consider the following piece of code:</p>\n<p>#include &#x3C;stdio.h></p>\n<p>int func3(){\nreturn 1;</p>\n<p>}</p>\n<p>main(){\nfunc3(1,2,3);\n}</p>\n<p>This gives no error with “gcc”, but an error with “g++“. Apparently, in c++, a function declared with no arguments is taken as void, whereas in c, it is simply unknown.</p>\n<p>Does gcc have a soft-spot for function parameters with too many arguments?</p>\n<p>Only time or maybe <a href=\"http://blogs.msdn.com/oldnewthing/\">Raymond Chen</a> can tell.</p>\n<p>del.icio.us Tags: <a href=\"http://del.icio.us/sss8ue/software\">software</a></p>","frontmatter":{"title":"Function pointers: number of parameters mismatch","date":"June 20, 2005"}}},"pageContext":{"slug":"/blog/2005-06-20-function-pointers-number-of-parameters-mismatch/","previous":{"fields":{"slug":"/blog/2005-06-13-people-in-eda-can-cook/"},"frontmatter":{"title":"People in EDA can cook!!!"}},"next":{"fields":{"slug":"/blog/2005-06-27-from-startup-to-sundown-comments-on-viral-marketing/"},"frontmatter":{"title":"From startup to... sundown: comments on viral marketing"}}}},"staticQueryHashes":["2778469899","2841359383","2882394463","3616023293"]}