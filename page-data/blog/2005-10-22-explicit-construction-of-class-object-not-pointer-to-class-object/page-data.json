{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2005-10-22-explicit-construction-of-class-object-not-pointer-to-class-object/","result":{"data":{"site":{"siteMetadata":{"title":"Lambdacurry"}},"markdownRemark":{"id":"cf785ade-c841-56e6-a31a-893e2cd56986","excerpt":"Consider the following piece of code: include <stdio.h> include <stdlib.h> using namespace std; class SSS{\n   public:\n       SSS(){\n        printf(“Calling…","html":"<p>Consider the following piece of code:</p>\n<h1>include &#x3C;stdio.h></h1>\n<h1>include &#x3C;stdlib.h></h1>\n<p>using namespace std;</p>\n<p>class SSS{\npublic:\nSSS(){\nprintf(“Calling constructorn”);\n}\n};</p>\n<p>typedef struct test{\nSSS s1;\n}test;</p>\n<p>int main(){\ntest *t1;\nt1=(test*)malloc( sizeof(test)*1);\nreturn 0;\n}</p>\n<p>Does the constructor of the class get called? Nope.</p>\n<p>Then how do you do it. The problem is, how do you explicitly call the constructor of a class object that is defined but not constructed. Usually, class objects are constructed as soon as they are declared. For e.g.</p>\n<blockquote>\n<p>SSS s1;</p>\n</blockquote>\n<p>The above will immediately call the constructor of SSS. However, this is a case where objects are declared, but not constructed. And there is no easy way to construct it now.</p>\n<p>First of all, this is bad design. If there is ever a necessity to explicitly declare a class object but construct it only later, then a pointer to a class should be used. However, this is comes from another problem that I encountered. Legacy code. Ah yes. the bane of any code writers existence. While code can almost be thought of a s poetry, this, ladies and gentlemen, is nothing short of blasphemy.</p>\n<p>In any case, the solution is not very difficult - placement new operator. Take a look at the modified code:</p>\n<h1>include &#x3C;stdio.h></h1>\n<h1>include &#x3C;stdlib.h></h1>\n<p>using namespace std;</p>\n<p>class SSS{\npublic:\nSSS(){\nprintf(“Calling constructorn”);\n}\nvoid* operator new(size_t size, SSS* s2){ //&#x3C;— need to overload</p>\n<p>printf(“Calling operator newn”);\nreturn (malloc(sizeof(SSS)*1));\n}\nprivate:\nint n;\n};</p>\n<p>typedef struct test{\nSSS s1;\n}test;</p>\n<p>int main(){\ntest *t1;\nt1=(test*)malloc( sizeof(test)*1);\nnew(&#x26;t1->s1)SSS;  //&#x3C;---- how cool is that</p>\n<p>return 0;\n}</p>\n<p>The key is overloading the new operator and calling the placement new operator in a weird way:</p>\n<blockquote>\n<p>new(&#x26;t1->s1)SSS</p>\n</blockquote>\n<p>Again… bad design.</p>\n<p>del.icio.us Tags: <a href=\"http://del.icio.us/sss8ue/software\">software</a></p>","frontmatter":{"title":"Explicit construction of class object (not pointer to class object)","date":"October 22, 2005"}}},"pageContext":{"slug":"/blog/2005-10-22-explicit-construction-of-class-object-not-pointer-to-class-object/","previous":{"fields":{"slug":"/blog/2005-10-16-fly-like-a-bird/"},"frontmatter":{"title":"Fly  like a bird"}},"next":{"fields":{"slug":"/blog/2005-10-23-when-vcs-turn-evil/"},"frontmatter":{"title":"When VC's turn evil"}}}},"staticQueryHashes":["2778469899","2841359383","2882394463","3616023293"]}